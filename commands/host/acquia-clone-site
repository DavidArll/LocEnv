#!/usr/bin/env bash

## Description: Clone a specific site from Acquia Cloud into the local DDEV environment with proper multisite setup.
## Usage: acquia-clone-site  [site_name]
## Example: ddev acquia-clone-site coorslight
## CanRunGlobally: false

set -e

# 📌 Paths
GLOBAL_CONFIG="$HOME/.ddev/global_config.yaml"
PROJECTS_JSON="$HOME/.ddev/acquia-projects.json"
SITES_PATH="docroot/sites"
LOCAL_SETTINGS_FILENAME="settings.local.php"
LOCAL_SETTINGS_EXAMPLE_FILENAME="example.settings.local.php"
LOCAL_SITE_YML="drush/sites/loc.site.yml"

# 📌 Variables
SITE_NAME=$1
DB_NAME=""
APP_NAME=""
ENVIRONMENT_ID=""
ENVIRONMENT_TYPE=""
TOKEN=""

# 📌 Functions

function verify_dependencies() {
  echo "🔄 Verificando dependencias necesarias..."
  CURRENT_OS="unknown"
  if [[ "$(uname)" == "Darwin" ]]; then
    CURRENT_OS="macOS"
  elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]]; then
    CURRENT_OS="Linux"
  elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" || "$(expr substr $(uname -s) 1 10)" == "MINGW64_NT" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" ]]; then
    CURRENT_OS="Windows" # Or more specifically Git Bash / MinGW
  fi
  echo "ℹ️ Detected OS: $CURRENT_OS"

  # Verify curl (normally pre-installed)
  if ! command -v curl &>/dev/null; then
    echo "⚠️ curl no encontrado."
    if [[ "$CURRENT_OS" == "macOS" ]]; then
      if ! command -v brew &>/dev/null; then
        echo "⚠️ Homebrew no está instalado. Por favor, instale Homebrew primero: https://brew.sh/"
        exit 1
      fi
      echo "Instalando curl vía Homebrew..."
      brew install curl
    elif [[ "$CURRENT_OS" == "Linux" ]]; then
      echo "Por favor, instale curl usando el gestor de paquetes de su distribución (ej. sudo apt-get install curl o sudo yum install curl)."
      exit 1
    elif [[ "$CURRENT_OS" == "Windows" ]]; then
      echo "Por favor, instale curl. Puede descargarlo desde https://curl.se/windows/ o usar un gestor de paquetes como Chocolatey (choco install curl) o winget."
      exit 1
    fi
  else
    echo "✅ curl ya está instalado."
  fi

  # Verify jq
  if ! command -v jq &>/dev/null; then
    echo "⚠️ jq no encontrado."
    if [[ "$CURRENT_OS" == "macOS" ]]; then
      if ! command -v brew &>/dev/null; then
        echo "⚠️ Homebrew no está instalado. Por favor, instale Homebrew primero: https://brew.sh/"
        exit 1
      fi
      echo "Instalando jq vía Homebrew..."
      brew install jq
    elif [[ "$CURRENT_OS" == "Linux" ]]; then
      echo "Por favor, instale jq usando el gestor de paquetes de su distribución (ej. sudo apt-get install jq o sudo yum install jq)."
      echo "Alternativamente, descargue el binario desde https://stedolan.github.io/jq/download/"
      exit 1
    elif [[ "$CURRENT_OS" == "Windows" ]]; then
      echo "Por favor, instale jq. Puede descargarlo desde https://stedolan.github.io/jq/download/ o usar un gestor de paquetes como Chocolatey (choco install jq) o winget."
      echo "Asegúrese de que esté en su PATH y accesible desde Git Bash/WSL si lo usa."
      exit 1
    fi
  else
    echo "✅ jq ya está instalado."
  fi

  # Verify yq
  if ! command -v yq &>/dev/null; then
    echo "⚠️ yq no encontrado."
    if [[ "$CURRENT_OS" == "macOS" ]]; then
      if ! command -v brew &>/dev/null; then
        echo "⚠️ Homebrew no está instalado. Por favor, instale Homebrew primero: https://brew.sh/"
        exit 1
      fi
      echo "Instalando yq vía Homebrew..."
      brew install yq
    elif [[ "$CURRENT_OS" == "Linux" ]];then
      echo "Por favor, instale yq usando el gestor de paquetes de su distribución (ej. sudo apt-get install yq o sudo yum install yq)."
      echo "Alternativamente, descargue el binario desde https://github.com/mikefarah/yq/releases"
      exit 1
    elif [[ "$CURRENT_OS" == "Windows" ]]; then
      echo "Por favor, instale yq. Puede descargarlo desde https://github.com/mikefarah/yq/releases o usar un gestor de paquetes como Chocolatey (choco install yq) o winget."
      echo "Asegúrese de que esté en su PATH y accesible desde Git Bash/WSL si lo usa."
      exit 1
    fi
  else
    echo "✅ yq ya está instalado."
  fi

  # Verify Homebrew only on macOS and if it's not already installed (it's used for jq/yq if they are missing)
  if [[ "$CURRENT_OS" == "macOS" ]]; then
    if ! command -v brew &>/dev/null; then
        echo "⚠️ Homebrew no está instalado. Instalando Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    else
        echo "✅ Homebrew ya está instalado."
    fi
  fi

  echo "✅ Todas las dependencias necesarias están instaladas o se ha informado al usuario."
}

# Ejecutar la verificación de dependencias al inicio del script
verify_dependencies

function validate_environment() {
    echo "🔄 Validando entorno..."
    [[ -f ".ddev/config.yaml" ]] || { echo "❌ Error: No es un proyecto DDEV válido."; exit 1; }
    [[ -f "$PROJECTS_JSON" ]] || { echo "❌ Error: Falta acquia-projects.json."; exit 1; }
    [[ -n "$SITE_NAME" ]] || { echo "❌ Error: Debes especificar un nombre de sitio."; exit 1; }
    echo "✅ Entorno validado correctamente."
}

function load_configuration() {
    echo "🔄 Cargando configuración..."
    ENV_DATA=$(jq -c --arg PROJECT_PATH "$PWD" '.projects[] | select(.project_path == $PROJECT_PATH)' "$PROJECTS_JSON")
    [[ -n "$ENV_DATA" ]] || { echo "❌ Error: Proyecto no registrado en acquia-projects.json."; exit 1; }
    APP_NAME=$(echo "$ENV_DATA" | jq -r '.app_name')
    ENVIRONMENT_ID=$(echo "$ENV_DATA" | jq -r '.environment_id')
    ENVIRONMENT_TYPE=$(echo "$ENV_DATA" | jq -r '.environment_type')
    PROJECT_PATH=$(echo "$ENV_DATA" | jq -r '.project_path')
    echo "✅ Configuración cargada correctamente."
}

function authenticate_with_acquia() {
    echo "🔄 Autenticando con Acquia..."
    ACQUIA_API_KEY=$(grep "ACQUIA_API_KEY=" "$GLOBAL_CONFIG" | sed 's/.*ACQUIA_API_KEY=\(.*\)$/\1/')
    ACQUIA_API_SECRET=$(grep "ACQUIA_API_SECRET=" "$GLOBAL_CONFIG" | sed 's/.*ACQUIA_API_SECRET=\(.*\)$/\1/')
    # Validar que las credenciales no estén vacías
    if [[ -z "$ACQUIA_API_KEY" || -z "$ACQUIA_API_SECRET" ]]; then
        echo "❌ Error: Las credenciales de Acquia no se encuentran en $GLOBAL_CONFIG."
        exit 1
    fi
    echo "   - ACQUIA_API_KEY y ACQUIA_API_SECRET obtenidos correctamente."

    # Obtener token y capturar respuesta completa para fines de debugging
    RESPONSE=$(curl -s -X POST "https://accounts.acquia.com/api/auth/oauth/token" \
        -d "client_id=$ACQUIA_API_KEY" \
        -d "client_secret=$ACQUIA_API_SECRET" \
        -d "grant_type=client_credentials")
    
    TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')
    
    if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
        echo "❌ Error: No se pudo obtener el token de autenticación."
        echo "   - Respuesta de Acquia: $RESPONSE"
        exit 1
    fi
    
    echo "✅ Autenticación exitosa. Token obtenido."
}

function verify_site_exists() {
    echo "🔄 Verificando existencia del sitio en Acquia..."
    DB_RESPONSE=$(curl -s -X GET "https://cloud.acquia.com/api/environments/$ENVIRONMENT_ID/databases" \
        -H "Authorization: Bearer $TOKEN" -H "Accept: application/json")
    SITE_DB_INFO=$(echo "$DB_RESPONSE" | jq -r --arg SITE "$SITE_NAME" '._embedded.items[]? | select(.name == $SITE)')
    [[ -n "$SITE_DB_INFO" ]] || { echo "❌ Error: Sitio '$SITE_NAME' no encontrado."; exit 1; }
    DB_NAME=$(echo "$SITE_DB_INFO" | jq -r '.name')
    echo "✅ Sitio '$SITE_NAME' encontrado en Acquia."
}

function site_already_cloned() {
    echo "🔄 Verificando si el sitio ya está clonado..."
    EXISTING_SITE=$(echo "$ENV_DATA" | jq -r --arg SITE_NAME "$SITE_NAME" '.databases[]? | select(. == $SITE_NAME)')
    [[ -n "$EXISTING_SITE" ]]
}

function verify_local_alias() {
    echo "🔄 Verificando alias local..."
    if ! grep -q "$DB_NAME:" "$LOCAL_SITE_YML"; then
        echo "⚠️  Alias local no encontrado, agregando..."
        echo "$DB_NAME:" >> "$LOCAL_SITE_YML"
        echo "  root: /var/www/html/docroot" >> "$LOCAL_SITE_YML"
        echo "  uri: '$DB_NAME-$ENVIRONMENT_TYPE.ddev.site'" >> "$LOCAL_SITE_YML"
    fi
    echo "✅ Alias local verificado."
}

function verify_database_settings() {
    echo "🔄 Verificando configuración de conexión a la base de datos..."
    SITE_PATH="$SITES_PATH/$DB_NAME"
    SETTINGS_PATH="$SITE_PATH/settings.php"
    SETTINGS_LOCAL_PATH="$SITE_PATH/$LOCAL_SETTINGS_FILENAME"
    SETTINGS_LOCAL_EXAMPLE_PATH="$SITES_PATH/$LOCAL_SETTINGS_EXAMPLE_FILENAME"
    
    DDEV_INFO=$(ddev describe -j)
    DDEV_DB_CONTAINER=$(echo "$DDEV_INFO" | jq -r '.raw.services.db.full_name')
    DDEV_PROJECT_NAME=$(echo "$DDEV_INFO" | jq -r '.raw.name')
    SITE_DOMAIN="${DB_NAME}-${ENVIRONMENT_TYPE}"

    if [[ ! -f "$SETTINGS_LOCAL_PATH" ]]; then
        if [[ -f "$SETTINGS_LOCAL_EXAMPLE_PATH" ]]; then
            echo "📄 Copying $LOCAL_SETTINGS_FILENAME from $LOCAL_SETTINGS_EXAMPLE_FILENAME..."
            cp "$SETTINGS_LOCAL_EXAMPLE_PATH" "$SETTINGS_LOCAL_PATH"
        else
            echo "⚠️  No example file found. Creating $LOCAL_SETTINGS_FILENAME from scratch..."
            touch "$SETTINGS_LOCAL_PATH"
        fi
    fi

    if ! grep -q "\$databases\['default'\]" "$SETTINGS_LOCAL_PATH"; then
        echo "🔧 Appending local configuration to $LOCAL_SETTINGS_FILENAME..."
        cat >> "$SETTINGS_LOCAL_PATH" << EOL

// DDEV-generated configuration for local development.
\$databases['default']['default'] = [
'database' => '$DB_NAME',
'username' => 'db',
'password' => 'db',
'host' => '$DDEV_DB_CONTAINER',
'port' => '3306',
'driver' => 'mysql',
'prefix' => '',
'namespace' => 'Drupal\\Core\\Database\\Driver\\mysql',
'collation' => 'utf8mb4_general_ci',
];

// Unique hash salt for Drupal security.
\$settings['hash_salt'] = '$(uuidgen)';

// Disable permissions hardening in local environment.
\$settings['skip_permissions_hardening'] = TRUE;

// Trusted host patterns.
\$settings['trusted_host_patterns'] = [
'^millercoorsd8-test\\.ddev\\.site\$',
'^$DB_NAME-$ENVIRONMENT_TYPE\\.ddev\\.site\$',
'^localhost\$',
'^127\\.0\\.0\\.1\$',
'^millercoorsd8-test\\.ddev\\.site:[0-9]+\$',
'^$DB_NAME-$ENVIRONMENT_TYPE\\.ddev\\.site:[0-9]+\$',
];

// Redis configuration if available in the environment.
if (getenv('REDIS_HOSTNAME')) {
\$settings['redis.connection']['interface'] = 'PhpRedis';
\$settings['redis.connection']['host'] = getenv('REDIS_HOSTNAME');
\$settings['redis.connection']['port'] = getenv('REDIS_PORT');
\$settings['cache']['default'] = 'cache.backend.redis';
}
EOL

    else
        echo "ℹ️  Configuration already exists in $LOCAL_SETTINGS_FILENAME. Skipping insertion."
    fi

    # Asegurar que settings.php incluya settings.local.php
    if [[ ! -f "$SETTINGS_PATH" ]]; then
        echo "⚠️  Creando settings.php..."
        cat > "$SETTINGS_PATH" << EOL
<?php

if (file_exists(\$app_root . '/' . \$site_path . '/settings.local.php')) {
  include \$app_root . '/' . \$site_path . '/settings.local.php';
}
EOL
    elif ! grep -q "settings.local.php" "$SETTINGS_PATH"; then
        echo "⚠️  Agregando inclusión de settings.local.php..."
        echo "
if (file_exists(\$app_root . '/' . \$site_path . '/settings.local.php')) {
  include \$app_root . '/' . \$site_path . '/settings.local.php';
}" >> "$SETTINGS_PATH"
    fi

    chmod 644 "$SETTINGS_PATH" "$SETTINGS_LOCAL_PATH"
    echo "✅ Configuración de conexión verificada."
}

function verify_multisite_config() {
    echo "🔄 Verificando configuración multisitio..."
    MULTISITE_CONFIG=".ddev/config.sites.yaml"
    SITE_DOMAIN="${DB_NAME}-${ENVIRONMENT_TYPE}"
    
    # Crear archivo si no existe con la estructura base
    if [[ ! -f "$MULTISITE_CONFIG" ]]; then
        echo "🔄 Creando nueva configuración multisitio..."
        mkdir -p "$(dirname "$MULTISITE_CONFIG")"
        cat > "$MULTISITE_CONFIG" << EOL
additional_hostnames:
database:
    additional_databases:
EOL
    fi

    # Verificar si el hostname ya existe
    if ! grep -q "^\s*-\s*${SITE_DOMAIN}\$" "$MULTISITE_CONFIG"; then
        echo "🔄 Agregando hostname ${SITE_DOMAIN}..."
        # Crear archivo temporal
        TEMP_FILE=$(mktemp)
        
        # Variable para rastrear si ya procesamos la sección
        HOSTNAME_ADDED=false
        DATABASE_ADDED=false
        
        while IFS= read -r line || [[ -n "$line" ]]; do
            echo "$line" >> "$TEMP_FILE"
            
            # Después de additional_hostnames, agregar el nuevo hostname si aún no se ha agregado
            if [[ "$line" =~ ^additional_hostnames:$ ]] && [[ "$HOSTNAME_ADDED" == "false" ]]; then
                echo "    - ${SITE_DOMAIN}" >> "$TEMP_FILE"
                HOSTNAME_ADDED=true
            fi
            
            # Después de additional_databases, agregar la nueva base de datos si aún no se ha agregado
            if [[ "$line" =~ ^.*additional_databases:$ ]] && [[ "$DATABASE_ADDED" == "false" ]]; then
                echo "        - ${DB_NAME}" >> "$TEMP_FILE"
                DATABASE_ADDED=true
            fi
        done < "$MULTISITE_CONFIG"
        
        # Si por alguna razón no se agregaron, agregarlos al final
        if [[ "$HOSTNAME_ADDED" == "false" ]]; then
            echo "additional_hostnames:" >> "$TEMP_FILE"
            echo "    - ${SITE_DOMAIN}" >> "$TEMP_FILE"
        fi
        if [[ "$DATABASE_ADDED" == "false" ]]; then
            echo "database:" >> "$TEMP_FILE"
            echo "    additional_databases:" >> "$TEMP_FILE"
            echo "        - ${DB_NAME}" >> "$TEMP_FILE"
        fi
        
        # Reemplazar el archivo original
        mv "$TEMP_FILE" "$MULTISITE_CONFIG"
        echo "✅ Configuración actualizada."
    else
        echo "ℹ️  El hostname ${SITE_DOMAIN} ya existe en la configuración."
    fi
    
    echo "✅ Configuración multisitio verificada."
}

function verify_configurations() {
    echo "🔄 Verificando configuraciones del sitio..."
    verify_local_alias
    verify_database_settings
    #verify_sites_local
    verify_multisite_config
    echo "✅ Configuraciones verificadas correctamente."
}

function sync_database() {
    echo "🔄 Sincronizando base de datos..."
    if ddev drush sql-sync "@$DB_NAME.$ENVIRONMENT_TYPE" "@loc.$DB_NAME" -y; then
        echo "✅ Base de datos sincronizada correctamente."
    else
        echo "⚠️  Falló la sincronización con Drush, usando backup de Acquia..."
        BACKUP_DATA=$(curl -s -X GET "https://cloud.acquia.com/api/environments/$ENVIRONMENT_ID/databases/$DB_NAME/backups" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json")
        
        if [[ $(echo "$BACKUP_DATA" | jq -r '._embedded.items | length') -eq 0 ]]; then
            echo "❌ No se encontraron backups para la base de datos '$DB_NAME'."
            exit 1
        fi
        
        LATEST_BACKUP=$(echo "$BACKUP_DATA" | jq -r '._embedded.items | max_by(.started_at)')
        DOWNLOAD_URL=$(echo "$LATEST_BACKUP" | jq -r '._links.download.href')
        
        echo "📥 Descargando backup desde $DOWNLOAD_URL..."
        curl -L -o "$DB_NAME.sql.gz" -X GET "$DOWNLOAD_URL" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/octet-stream"
        
        echo "🔄 Importando base de datos en DDEV..."
        ddev import-db --database="$DB_NAME" --file="$DB_NAME.sql.gz"
        rm -f "$DB_NAME.sql.gz"
        echo "✅ Base de datos importada correctamente."
    fi
}

function verify_directory_permissions() {
    echo "🔄 Verificando permisos de directorios..."
    SITE_PATH="$SITES_PATH/$DB_NAME"
    
    # Crear directorios necesarios si no existen
    mkdir -p "$SITE_PATH/files"
    
    # Establecer permisos base
    chmod 755 "$SITE_PATH"
    chmod 755 "$SITE_PATH/files"
    
    echo "🔄 Ajustando propietario de archivos dentro del contenedor..."
    # Usar sudo dentro del contenedor para cambiar el propietario
    if ! ddev exec "sudo chown -R www-data:www-data /var/www/html/$SITE_PATH/files"; then
        echo "⚠️  No se pudieron cambiar los permisos usando sudo, intentando sin sudo..."
        if ! ddev exec "chown -R www-data:www-data /var/www/html/$SITE_PATH/files"; then
            echo "⚠️  No se pudieron establecer los permisos correctos. Los archivos podrían no ser escribibles."
            # Continuar a pesar del error, ya que los archivos podrían funcionar con los permisos actuales
        fi
    fi
    
    echo "✅ Permisos de directorios verificados."
}

function sync_files() {
    echo "🔄 Sincronizando archivos..."
    
    # Asegurar que el directorio de destino existe y tiene los permisos correctos
    echo "test 0"
    mkdir -p "$SITES_PATH/$DB_NAME/files"
    chmod 755 "$SITES_PATH/$DB_NAME/files"
    ddev exec sudo chown -R www-data:www-data /var/www/html/docroot/sites/"$DB_NAME"/files
    echo "test 1"
    # Ejecutar la sincronización y capturar la salida y el código de salida
    verify_directory_permissions
    echo "ddev drush rsync @$DB_NAME.$ENVIRONMENT_TYPE:%files/ @loc.$DB_NAME:%files/ -y --verbose"
    rsync_output=$(ddev drush rsync @$DB_NAME.$ENVIRONMENT_TYPE:%files/ @loc.$DB_NAME:%files/ -y --verbose 2>&1)
    RSYNC_EXIT=$?
    echo "test 2"
    if [[ $RSYNC_EXIT -eq 0 ]]; then
        echo "✅ Archivos sincronizados correctamente."
        verify_directory_permissions
    elif [[ $RSYNC_EXIT -eq 23 ]]; then
        echo "⚠️ Sincronización completada con warnings (algunos archivos no se transfirieron)."
        echo "$rsync_output"
        verify_directory_permissions
    else
        echo "❌ Error al sincronizar archivos (código de salida: $RSYNC_EXIT)."
        echo "$rsync_output"
        echo "ℹ️ Por favor, intenta ejecutar manualmente el siguiente comando:"
        echo "    ddev drush rsync \"@$DB_NAME.$ENVIRONMENT_TYPE:%files/\" \"@loc.$DB_NAME:%files/\" -y"
        echo "Continuando con el proceso..."
        # No se detiene el script, simplemente se continúa.
    fi
}



function update_acquia_projects() {
    echo "🔄 Actualizando registro de sitios clonados..."
    local TEMP_FILE=$(mktemp)
    
    if [[ ! -f "$PROJECTS_JSON" ]]; then
        echo "⚠️  Archivo de proyectos no encontrado, creando uno nuevo..."
        cat > "$PROJECTS_JSON" << EOL
{
  "projects": []
}
EOL
    fi
    jq --arg path "$PWD" \
       --arg db "$DB_NAME" \
       '(.projects[] | select(.project_path == $path)).databases |= if . then (. + [$db] | unique) else [$db] end' \
       "$PROJECTS_JSON" > "$TEMP_FILE"

    if [[ $? -eq 0 ]] && [[ -s "$TEMP_FILE" ]]; then
        mv "$TEMP_FILE" "$PROJECTS_JSON"
        echo "✅ Registro actualizado correctamente."
    else
        rm -f "$TEMP_FILE"
        echo "⚠️  Error al actualizar el registro, creando nuevo registro..."
        # Si falla, crear una nueva estructura
        cat > "$PROJECTS_JSON" << EOL
{
  "projects": [
    {
      "project_path": "$PWD",
      "databases": ["$DB_NAME"]
    }
  ]
}
EOL
    fi
}

function clone_site_from_scratch() {
    echo "🔄 Iniciando clonación desde cero..."
    verify_configurations
    sync_database
    #sync_files
    update_acquia_projects
    echo "✅ Clonación desde cero completada."
}

function offer_sync_options() {
    echo "🔄 Verificando opciones de sincronización..."
    read -p "¿Deseas sincronizar la base de datos? [y/N]: " SYNC_DB
    if [[ "$SYNC_DB" =~ ^[Yy]$ ]]; then
        sync_database
    fi

    #read -p "¿Deseas sincronizar los archivos? [y/N]: " SYNC_FILES
    #if [[ "$SYNC_FILES" =~ ^[Yy]$ ]]; then
     #   sync_files
    #fi
 #   echo "✅ Sincronización completada."
}

ddev auth ssh

function verify_database_access() {
    echo "🔄 Verificando acceso a la base de datos..."
    if ! ddev drush @loc."$DB_NAME" sql-query "SHOW DATABASES LIKE '$DB_NAME';" > /dev/null 2>&1; then
        echo "⚠️  Base de datos '$DB_NAME' no encontrada o inaccesible."
        return 1
    fi
    echo "✅ Acceso a base de datos verificado."
}

function verify_ddev_config() {
    echo "🔄 Verificando configuración de DDEV..."
    
    # Verificar que el hostname esté en la configuración
    if ! ddev describe -j | jq -e --arg site "${DB_NAME}-${ENVIRONMENT_TYPE}.ddev.site" '.raw.hostnames[] | select(. == $site)' > /dev/null; then
        echo "⚠️  Hostname no encontrado en la configuración de DDEV."
        return 1
    fi

    if ! ddev describe -j | jq -e --arg db "$DB_NAME" '.raw.dbinfo.databases[]? | select(. == $db)' > /dev/null 2>&1; then
        echo "⚠️  Base de datos no encontrada en la configuración de DDEV."
        return 1
    fi
    
    echo "✅ Configuración de DDEV verificada."
}
function fix_host_permissions() {
    echo "🔄 Corrigiendo permisos en el host para el directorio de archivos..."
    # Construir la ruta absoluta al directorio de archivos en el host
    HOST_SITE_FILES="$PROJECT_PATH/docroot/sites/$DB_NAME/files"
    
    if [[ -d "$HOST_SITE_FILES" ]]; then
        chmod -R 775 "$HOST_SITE_FILES"
        if [[ "$CURRENT_OS" == "macOS" || "$CURRENT_OS" == "Linux" ]]; then
            chown -R "$USER":staff "$HOST_SITE_FILES"
        else
            echo "ℹ️ Skipping host chown command on Windows for $HOST_SITE_FILES"
        fi
        echo "✅ Permisos en host actualizados en $HOST_SITE_FILES"
    else
        echo "⚠️ El directorio $HOST_SITE_FILES no existe, creándolo..."
        mkdir -p "$HOST_SITE_FILES"
        chmod -R 775 "$HOST_SITE_FILES"
        if [[ "$CURRENT_OS" == "macOS" || "$CURRENT_OS" == "Linux" ]]; then
            chown -R "$USER":staff "$HOST_SITE_FILES"
        else
            echo "ℹ️ Skipping host chown command on Windows for $HOST_SITE_FILES"
        fi
        echo "✅ Directorio $HOST_SITE_FILES creado y permisos configurados."
    fi
}

function verify_sites_php() {
    echo "🔄 Verificando registro en sites.php..."
    SITES_PHP="$SITES_PATH/sites.php"
    if [[ ! -f "$SITES_PHP" ]]; then
        echo "❌ Error: $SITES_PHP no existe. Se espera que ya exista."
        exit 1
    fi

    # Buscar el bloque de inclusión. Se utiliza una cadena que coincide con la línea de apertura.
    if ! grep -q 'if (file_exists(__DIR__ . "/sites.local.php")) {' "$SITES_PHP"; then
        echo "⚠️  Bloque de carga de sites.local.php no encontrado en sites.php. Agregándolo al final..."
        cat << 'EOF' >> "$SITES_PHP"

if (file_exists(__DIR__ . "/sites.local.php")) {
  require __DIR__ . "/sites.local.php";
}
EOF
    else
        echo "ℹ️  Bloque de carga ya presente en sites.php, se omite su inserción."
    fi

    echo "✅ Verificación completada en sites.php."
}
function update_sites_local_php() {
  echo "🔄 Verificando sites.local.php..."

  SITES_LOCAL="$SITES_PATH/sites.local.php"
  SITE_DOMAIN="${DB_NAME}-${ENVIRONMENT_TYPE}.ddev.site"

  if [[ ! -f "$SITES_LOCAL" ]]; then
    echo "<?php" > "$SITES_LOCAL"
    echo "✅ Archivo sites.local.php creado."
  fi

  # Verificar si ya existe el mapeo
  if grep -q "\['$SITE_DOMAIN'\]" "$SITES_LOCAL"; then
    echo "ℹ️  El dominio $SITE_DOMAIN ya está mapeado en sites.local.php"
  else
    echo "\$sites['$SITE_DOMAIN'] = '$DB_NAME';" >> "$SITES_LOCAL"
    echo "✅ Mapeo agregado: \$sites['$SITE_DOMAIN'] = '$DB_NAME';"
  fi
}


function finalize_process() {
    echo "🔄 Finalizando proceso..."
    
    # Agregar las nuevas verificaciones
    # Verificar y actualizar registros en sites.php y sites.local.php
    verify_sites_php
    update_sites_local_php
    # Primero, ajustar permisos en el host
    fix_host_permissions
    # Luego, verificar y ajustar permisos dentro del contenedor
    verify_directory_permissions
    verify_database_access
    #verify_ddev_config
    
    # Reiniciar DDEV para aplicar cambios
    ddev restart
    
    # Limpiar caché de Drupal
    ddev drush @loc.$DB_NAME cr
    
    echo "✅ Sitio '$DB_NAME' disponible en: https://${DB_NAME}-${ENVIRONMENT_TYPE}.ddev.site"
    echo "ℹ️  Si el sitio no responde, verifica los siguientes puntos:"
    echo "   1. La URL https://${DB_NAME}-${ENVIRONMENT_TYPE}.ddev.site es accesible"
    echo "   2. La base de datos '$DB_NAME' existe y tiene contenido"
    echo "   3. Los archivos de configuración en sites/$DB_NAME están correctos"
    echo "   4. Los permisos de los directorios son correctos"
}

function fix_line_endings() {
    echo "🔄 Corrigiendo finales de línea..."
    local file="$1"
    if [[ -f "$file" ]]; then
        # Crear un archivo temporal
        local temp_file=$(mktemp)
        # Convertir CRLF a LF
        tr -d '\r' < "$file" > "$temp_file"
        mv "$temp_file" "$file"
        echo "✅ Finales de línea corregidos en $file"
    fi
}

function verify_drush_files() {
    echo "🔄 Verificando archivos de Drush..."
    
    # Corregir finales de línea en archivos importantes
    fix_line_endings "$LOCAL_SITE_YML"
    fix_line_endings "$SITES_PATH/sites.php"
    fix_line_endings "$SITES_PATH/sites.local.php"
    
    # Verificar permisos
    chmod 644 "$LOCAL_SITE_YML"
    
    echo "✅ Archivos de Drush verificados."
}

function verify_drush_executable() {
    echo "🔄 Verificando ejecutable de Drush..."
    
    # Primero corregir el ejecutable local
    if [[ -f "vendor/bin/drush" ]]; then
        echo "🔧 Corrigiendo finales de línea en vendor/bin/drush..."
        # Obtener los permisos actuales
        if [[ "$CURRENT_OS" == "macOS" ]]; then
          CURRENT_PERMS=$(stat -f %A "vendor/bin/drush")
        elif [[ "$CURRENT_OS" == "Linux" ]]; then
          CURRENT_PERMS=$(stat -c %a "vendor/bin/drush")
        else
          # Windows: Skip permission check or set a default. Drush is likely run via DDEV exec in Linux context.
          echo "ℹ️  Saltando la verificación de permisos de Drush en Windows. Se gestionará dentro del contenedor DDEV."
          CURRENT_PERMS="755" # Default sensible permission if needed, though may not be directly applied on host.
        fi
        
        # Crear un archivo temporal
        TEMP_FILE=$(mktemp)
        
        # Convertir CRLF a LF
        tr -d '\r' < "vendor/bin/drush" > "$TEMP_FILE"
        
        # Aplicar los mismos permisos
        chmod "$CURRENT_PERMS" "$TEMP_FILE"
        
        # Reemplazar el archivo original
        mv "$TEMP_FILE" "vendor/bin/drush"
        
        echo "✅ Drush ejecutable corregido"
    fi
    
    # Corregir dentro del contenedor usando ddev exec
    echo "🔧 Corrigiendo Drush dentro del contenedor..."
    ddev exec "sudo find /var/www/html/vendor/bin -name 'drush' -type f -exec sh -c 'tr -d \"\r\" < \"{}\" > \"{}.tmp\" && mv \"{}.tmp\" \"{}\"' \;"
    
    # Verificar que Drush funciona
    if ddev exec "drush status" > /dev/null 2>&1; then
        echo "✅ Verificación de Drush completada."
    else
        echo "⚠️  Advertencia: Drush podría no estar funcionando correctamente."
        # Continuamos de todos modos, ya que esto no es crítico
    fi
}

# 📌 Main execution flow
function main() {
    echo "🚀 Iniciando proceso de clonación para el sitio: $SITE_NAME"
    
    validate_environment
    load_configuration
    authenticate_with_acquia
    verify_site_exists
    
    if site_already_cloned; then
        echo "ℹ️  El sitio ya está clonado. Verificando configuraciones..."
        verify_configurations
        verify_drush_files
        offer_sync_options
    else
        echo "ℹ️  Clonando sitio por primera vez..."
        clone_site_from_scratch
        verify_drush_files
    fi
    
    finalize_process
    echo "🎉 Proceso completado exitosamente!"
}

# Execute main function
main